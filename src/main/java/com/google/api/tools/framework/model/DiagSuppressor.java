/*
 * Copyright (C) 2016 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.api.tools.framework.model;

import com.google.api.tools.framework.model.Diag.Kind;
import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nullable;

/**
 * Manages the set of rules for suppressing {@link Kind#WARNING} Diags. TODO(user): Change
 * DiagSuppressor to implement DiagCollector and use this as the DiagCollector in Model.java,
 * pending work in cl/121629221
 */
public class DiagSuppressor {

  // Regexp to match a suppression directive argument.
  // TODO(user): Should this pattern be more restrictive?
  private static final Pattern SUPPRESSION_DIRECTIVE_PATTERN =
      Pattern.compile("\\s*(?<aspect>[^-]+)-(?<rule>.*)");

  // A map of per-element regexp patterns which characterize suppressed warnings.
  private Map<Element, String> suppressions = Maps.newHashMap();

  // The same as above, but with compiled patterns.
  private Map<Element, Pattern> compiledSuppressions = Maps.newHashMap();

  // Global suppression pattern that is not tied to any Element.
  // This is useful to check if a warning is suppressed when the caller
  // does not have an instance of the model and only has instance of Diag and the Location.
  private Pattern compilerGlobalSuppressionPattern = Pattern.compile("");

  private final DiagCollector diagCollector;

  public DiagSuppressor(DiagCollector diagCollector) {
    this.diagCollector = Preconditions.checkNotNull(diagCollector, "diagCollector cannot be null");
  }
  /**
   * Adds a user-level suppression directive. The directive must be given in the form 'aspect-rule',
   * or 'aspect-*' to match any rule. Is used in comments such as '(== suppress_warning http-* ==)'
   * which will suppress all lint warnings generated by the http aspect.
   */
  public void addSuppressionDirective(
      Element elem, String directive, List<ConfigAspect> configAspects) {
    // Validate the directive syntax.
    Matcher matcher = SUPPRESSION_DIRECTIVE_PATTERN.matcher(directive);
    if (!matcher.matches()) {
      diagCollector.addDiag(
          Diag.error(
              elem.getLocation(),
              "The warning_suppression '%s' does not match the expected pattern "
                  + "'<aspect>-<rule>' or '<aspect>-*'.",
              directive));
      return;
    }

    // Get aspect and rule name and search for matching aspect and rule.
    String aspectName = matcher.group("aspect");
    String ruleName = matcher.group("rule");
    ConfigAspect matching = null;
    for (ConfigAspect aspect : configAspects) {
      if (aspect.getAspectName().equals(aspectName)) {
        matching = aspect;
        break;
      }
    }
    if (matching == null) {
      diagCollector.addDiag(
          Diag.error(
              elem.getLocation(),
              "The config aspect '%s' used in warning suppression '%s' is unknown.",
              aspectName,
              directive));
      return;
    }
    if (!"*".equals(ruleName) && !matching.getLintRuleNames().contains(ruleName)) {
      diagCollector.addDiag(
          Diag.warning(
              elem.getLocation(),
              "The rule '%s' in aspect '%s' used in warning suppression '%s' is unknown.",
              ruleName,
              aspectName,
              directive));
      return;
    }

    // Add the suppression pattern.
    addPattern(elem, suppressionPattern(aspectName, ruleName));
  }

  // TODO(user): See if we can avoid the type case.
  public boolean isDiagSuppressed(Diag diag, Object elementOrLocation) {
    if (elementOrLocation instanceof Element
        && isSuppressedWarning(diag, (Element) elementOrLocation)) {
      return true;
    } else if (elementOrLocation instanceof Location
        && compilerGlobalSuppressionPattern.matcher(diag.getMessage()).matches()) {
      return true;
    }

    return false;
  }

  /**
   * Checks whether the given diagnosis is suppressed for the given element. This checks the
   * suppression pattern for this element and all elements, inserting the model for global
   * suppressions as a virtual parent. Only Diags of Kind {@link Kind#WARNING} can be suppressed
   */
  public boolean isSuppressedWarning(Diag diag, Element elem) {
    if (diag.getKind() != Diag.Kind.WARNING) {
      return false;
    }
    Element current = elem;
    while (current != null) {
      Pattern pattern = getPattern(current);
      if (pattern != null && pattern.matcher(diag.getMessage()).matches()) {
        return true;
      }
      if (current instanceof Model) {
        // Top-most parent tried.
        break;
      }
      if (current instanceof ProtoElement) {
        current = ((ProtoElement) current).getParent();
      } else {
        current = null;
      }
      if (current == null) {
        // Insert the model as a virtual parent.
        current = elem.getModel();
      }
    }
    return false;
  }

  // Adds a pattern for given element.
  public void addPattern(Element elem, String pattern) {
    String elemPattern = suppressions.get(elem);
    if (elemPattern == null) {
      elemPattern = pattern;
    } else {
      elemPattern = elemPattern + "|(" + pattern + ")";
      compiledSuppressions.remove(elem);
    }
    suppressions.put(elem, elemPattern);

    // Check if suppression is on global model element.
    if (elem instanceof Model && elemPattern != null) {
      compilerGlobalSuppressionPattern = Pattern.compile(elemPattern, Pattern.DOTALL);
    }
  }

  // Gets a pattern for given element. This compiles the pattern on demand.
  @Nullable
  public Pattern getPattern(Element elem) {
    Pattern pattern = compiledSuppressions.get(elem);
    if (pattern == null) {
      String source = suppressions.get(elem);
      if (source == null) {
        return null;
      }
      pattern = Pattern.compile(source, Pattern.DOTALL);
      compiledSuppressions.put(elem, pattern);
    }
    return pattern;
  }

  // Returns a pattern string to match a style warning with given aspect and rule name.
  private static String suppressionPattern(String aspectName, String ruleName) {
    return String.format(
        "\\(lint\\)\\s*%s-%s:.*",
        Pattern.quote(aspectName),
        "*".equals(ruleName) ? "\\w+" : Pattern.quote(ruleName));
  }
}
